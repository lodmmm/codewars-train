# codewars-train

codewars 里面的练习题的个人解答, 以及一些平时遇到的场景的一些函数的封装

1. to two one => 入参两个字母字符串(纯小写), 返回两个字符串里出现过的字母的集合, 要求结果集合无重复且有序
    - 两个字符串处理方式相同, 先做 `concat` 处理
    - 初始化一个结果数组
    - `for` 循环遍历字符串, 利用 `indexOf` 方法确定结果结果数组里面是不是有当前判断的字母, `有 => pass`, `没有 => push`
    - 全小写字母, 可以直接 `sort()`, 之后 `arr => str`, 直接 `join('')`
2. highest and lowest => 入参为类似 `'4 5 29 54 4 0 -214 542 -64 1 -3 6 -6'` 的字符串, 要求找到其中的最大和最小的数字
    - 2017-01-11
    - 先做 `str => arr` 的操作
    - 初始化 `low => Infinity`, `high => -Infinity`
    - 一次循环
        + `index < low` ? `low = index` : `do nothing`
        + `index > high` ? `high = index` : `do nothing`
    - 循环结束, 寻找也结束, 得到了 `low` 和 `high`
    - 2017-01-11
    - 直接使用 `sort` 函数进行排序, 排序之后取第一位和最后一位即可
3. number-format-thousand => 千分位分隔符, 支持自己配置 point 标示和 thousands 的标示
    - `number => str`, 去空格
    - `point` 和 `thousands` 规定默认值
    - 判断是不是有小数部分, 分开处理
    - 调用内部函数 `formatWhole`, 得到结果, 内部函数实现思路 :
        - 三位三位的取, 所以用正则 `match`
        - `match` 不到的位单独考虑
        - 最终结果拼上 `thousands` 分隔符
4. shortest-word => 传入一大串以空格分割的单词的字符串, 类似这种 `'bitcoin take over the world maybe who knows perhaps'`, 要求返回最短的一个的 `length`
    - 2017-01-12
    - 先 `split(' ')` 处理字符串
    - 创建一个数组, 做桶排序, `length` 作为桶的下标 --- 这里依据是否为空, 来确定是 `push` 还是初始化子项数组没太大意义, 就直接覆盖就可以了貌似
    - 调用 `array` 的 `some` 方法, 找到第一个不为空的下标, 就是最小长度了
    - 2017-01-12
    - `split(' ')` 处理字符串
    - 字符串数组转 `length` 数组
    - 找 `length` 数组里面的最小值
5. your-order => 传入一大串以空格分割的单词的字符串, 每个单词里面都有一个数字, 最后返回以数字排序的字符串
    - 2017-01-12
    - 非空检测
    - `split(' ')` 处理字符串
    - `/\d/` `match` 出数字, 以这个数字把每个单词放到数组的相应位置
    - 删除第 0 项
    - `join(' ')`, `arr => str`
    - 2017-01-12
    - 直接把字符串通过 `sort` 排序
    - `sort` 内部通过 `match` 出来的东西进行排序
    - 最后 `join(' ')`, `arr => str`
6. sum-of-numbers => 传入两个数字, 把两个数字之间的数字都加起来, 返回这个加起来的结果
    - 2017-01-13
    - 找到 `dir`
    - 找到 `length`
    - 一个 `for` 循环
    - 2017-01-13
    - 头尾相加乘一共有几对。。
7. largest-5-digit-number => 传入一大串数字, 找到每五个拼起来的数字里面最大的那个
    - 2016-01-14
    - 找到所有数字, 依次比较, 最后得出结果
    - 2016-01-14
    - 进行一次循环, 中间量为当前最大的那个量
    - 循环结束, 则寻找结束
    - 直接返回中间量就好